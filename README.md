

# sketch_oct8a解析

這個Arduino程式實現了一個簡單的按鈕控制LED的功能。每次按下按鈕，LED的狀態就會切換一次（開啟或關閉）。

## 程式結構

程式主要分為三個部分：
1. 全局變數宣告
2. `setup()` 函數
3. `loop()` 函數

## 全局變數

```cpp
bool p16 = digitalRead(16);  // 讀取引腳16的初始狀態
bool led_state = HIGH;  // 設置LED初始狀態為高電平（開啟）
```

- `p16`：用於存儲引腳16（按鈕）的狀態
- `led_state`：用於記錄LED的當前狀態，初始設為高電平（開啟）

## setup() 函數

```cpp
void setup() {
  Serial.begin(9600);  // 初始化串口通信，波特率為9600
  pinMode(16, INPUT_PULLUP);  // 設置引腳16為輸入模式，啟用內部上拉電阻
  pinMode(4, OUTPUT);  // 設置引腳4為輸出模式
  digitalWrite(4, LOW);  // 初始化引腳4為低電平
}
```

`setup()` 函數只在Arduino啟動時執行一次，用於初始化設置：

- 初始化串口通信，波特率為9600
- 設置引腳16為輸入模式，並啟用內部上拉電阻（用於連接按鈕）
- 設置引腳4為輸出模式（用於控制LED）
- 初始化引腳4為低電平，確保LED最初是關閉的

## loop() 函數

```cpp
void loop() {
  p16 = digitalRead(16);  // 讀取引腳16的當前狀態
  Serial.println(p16);  // 通過串口輸出引腳16的狀態

  if (p16 == 0) {  // 如果引腳16為低電平（按鈕被按下）
    digitalWrite(4, HIGH);  // 將引腳4設置為高電平
    led_state = !led_state;  // 切換LED狀態
  }

  digitalWrite(4, led_state);  // 根據led_state設置引腳4的狀態
  delay(100);  // 延遲100毫秒
}
```

`loop()` 函數會不斷重複執行，實現主要功能：

1. 讀取引腳16（按鈕）的狀態
2. 通過串口輸出按鈕狀態（用於調試）
3. 如果檢測到按鈕被按下（引腳16為低電平）：
   - 將引腳4（LED）設置為高電平
   - 切換 `led_state` 的狀態
4. 根據 `led_state` 設置LED的狀態
5. 延遲100毫秒，以防止按鈕彈跳和降低CPU負載

## 程式邏輯說明

- 使用 `INPUT_PULLUP` 模式為按鈕提供內部上拉電阻，簡化了外部電路設計
- 當按鈕未按下時，引腳16讀取為高電平（1）；按下時為低電平（0）
- 每次檢測到按鈕按下，就會切換LED的狀態
- 使用 `led_state` 變數來記錄和控制LED的開關狀態
- 通過串口輸出按鈕狀態，方便監控和調試

